# `r paste0("Subsection: ", plantName1)`

```{r}

if (!dir.exists(plantDirOut)) dir.create(plantDirOut, recursive = TRUE)

```

## Ortho sources

```{r, chunk.label = paste0("sources_", plantName1), echo=TRUE, eval=TRUE}

fp = file.path('..', 'intermediate')
fl = list.files(fp, full.names = TRUE)
fl = fl[grep(paste0('PLAZA_selection|FastOMA2_ath-pairs|JCVI_MCScanX_plants|comparaPlants_hc-to-ath|OrthoDB_fruitTrees|RBH_fruitTrees'), fl)] # change names
fl = fl[grep('\\.zip$', fl)]

df = NULL

for (i in fl){
  
  print(i)
  
  dt = data.table::fread(i)
  us = unique(dt$source)
  
  if(us == 'ensembl-compara') {
    
    dt = dt[dt$homology_species == plantName2, ]
    # print(head(dt))
    dt = dt[, c(1,2,6,7,10)]
    colnames(dt) = c('from_geneID', 'from_protID', 'to_geneID', 'to_protID', 'source')
    df = rbind(df, dt)
    
  } else if (us == 'FastOMA') {
    
    dt = dt[dt$to_plant == plantName4, ]
    # print(head(dt))
    dt = dt[, c(2,1, 4,3, 5)]
    colnames(dt) = c('from_geneID', 'from_protID', 'to_geneID', 'to_protID', 'source')
    dt[, 1] = NA
    dt[, 3] = NA
    df = rbind(df, dt)
    
  } else if (us == 'MCScanX') {
    
    # dt = dt[grepl('stu', dt$to_plant), ]
    dt = dt[grepl(plantName3, dt$to_plant), ] #  change names
    # print(head(dt))
    dt = dt[, c(2,1, 4,3, 6)]
    colnames(dt) = c('from_geneID', 'from_protID', 'to_geneID', 'to_protID', 'source')
    dt[, 1] = NA
    dt[, 3] = NA
    df = rbind(df, dt)
    
  } else if (us == 'PLAZA') {
    
    dt = dt[dt$orthologous_species == plantName1, ]
    # print(head(dt))
    colnames(dt) = c('from_geneID', 'from_protID', 'to_geneID', 'to_protID', 'source')
    dt[, 2] = NA
    dt[, 4] = NA
    df = rbind(df, dt)
    
  } else if (us == 'OrthoDB') {
    
    dt = dt[dt$to_plant == plantName1, ]
    # print(head(dt))
    colnames(dt) = c('from_geneID', 'from_protID', 'to_geneID', 'to_protID', 'source')
    dt[, 2] = NA
    dt[, 4] = NA
    df = rbind(df, dt)
    
  } else if (us == 'RBH') {
    
    dt = dt[dt$to_plant == plantName1, ]
    # print(head(dt))
    colnames(dt) = c('from_geneID', 'from_protID', 'to_geneID', 'to_protID', 'source')
    dt[, 2] = NA
    dt[, 4] = NA
    df = rbind(df, dt)
    
  }   else print ('ERROR: Unknown source')
}


table(df$source)



df %>%
  dplyr::group_by(source) %>%
  dplyr::slice_head(n = 2) %>%
  dplyr::bind_rows(df %>% dplyr::group_by(source) %>% dplyr::slice_tail(n = 2)) %>%
  dplyr::arrange(source) %>%
  dplyr::ungroup() -> first_last_three_per_source

print(first_last_three_per_source, n = nrow(first_last_three_per_source))


```


## Transcript (aka protein) to geneID

```{r, chunk.label = paste0("all-IDs_", plantName1), echo=TRUE, eval=TRUE}

ind = which(is.na(df$from_geneID))
df$from_geneID[ind] = sub("\\.[0-9]+$", "", df$from_protID[ind])

# orfs!
ind = grep('\\.', df$from_geneID)
table(df[ind, ]$source)
print(df[ind, ])


ind = which(is.na(df$to_geneID))
df$to_geneID[ind] = sub(pattern_in, pattern_out, df$to_protID[ind]) # change logic as needed



df %>%
  dplyr::group_by(source) %>%
  dplyr::slice_head(n = 2) %>%
  dplyr::bind_rows(df %>% dplyr::group_by(source) %>% dplyr::slice_tail(n = 2)) %>%
  dplyr::arrange(source) %>%
  dplyr::ungroup() -> first_last_three_per_source

print(first_last_three_per_source, n = nrow(first_last_three_per_source))


summary_na = df[, .(
  na_to_geneID = sum(is.na(to_geneID)),
  na_to_protID = sum(is.na(to_protID))
), by = source]
print(summary_na)

```

## PLAZA and ensembl-compara with Orthofinder

here we have some loses because genes between versions do not translate well!

```{r, chunk.label = paste0("inconsistent-IDs_", plantName1), echo=TRUE, eval=TRUE}

fp = file.path('..', 'input', 'OrthoFinder', plantDirIn)
fl = list.files(fp)
fn = fl[grep('Compara_', fl)] # change filename
compara = data.table::fread(file.path(fp, fn))
fn = fl[grep('PLAZA_', fl)] # change filename
if (length(fn) != 0) {
  plaza = data.table::fread(file.path(fp, fn))
} else {
  plaza = data.frame(matrix(ncol = 4, nrow = 0))
}


compara = compara[compara$Species == ref_genome, ] # change name
plaza = plaza[plaza$Species == ref_genome, ] # change name


colnames(compara)[3] = colnames(plaza)[3] = 'source'


compara[, OrthoDB_list := stringr::str_split(source, pattern = ",\\s*")] # change colname
compara[, Orthologs_list := stringr::str_split(Orthologs, pattern = ",\\s*")]
result = compara[, {
  # Cartesian join of OrthoDB_list and Orthologs_list for this row
  pairs = CJ(OrthoDB_list[[1]], Orthologs_list[[1]], sorted = FALSE)
  setnames(pairs, c("OrthoDB_ID", "Ortholog"))
  pairs
}, by = seq_len(nrow(compara))]
compara = result[, seq_len := NULL]
# compara$Ortholog = sapply(compara$Ortholog, function(x) paste(unlist(strsplit(x, "_"))[1:2], collapse = "_")) # change when needed
compara$OrthoDB_ID = sub(compara_pattern_in1, compara_pattern_out1, 
                         sub(compara_pattern_in2, compara_pattern_out2, compara$OrthoDB_ID)) # change when needed
compara = compara[!duplicated(compara), ]
head(compara)


if (nrow(plaza) != 0) {
  plaza[, OrthoDB_list := stringr::str_split(source, pattern = ",\\s*")] # change colname
  plaza[, Orthologs_list := stringr::str_split(Orthologs, pattern = ",\\s*")]
  result = plaza[, {
    # Cartesian join of OrthoDB_list and Orthologs_list for this row
    pairs = CJ(OrthoDB_list[[1]], Orthologs_list[[1]], sorted = FALSE)
    setnames(pairs, c("OrthoDB_ID", "Ortholog"))
    pairs
  }, by = seq_len(nrow(plaza))]
  plaza = result[, seq_len := NULL]
  # plaza$Ortholog = sapply(plaza$Ortholog, function(x) paste(unlist(strsplit(x, "_"))[1:2], collapse = "_")) # change when needed
  plaza$OrthoDB_ID = sub(plaza_pattern_in1, '', sub(plaza_pattern_in2, "", plaza$OrthoDB_ID)) # change when needed
  plaza = plaza[!duplicated(plaza), ]
  head(plaza)  
}

if (flag3) compara$Ortholog = gsub('.* ', '', compara$Ortholog)

if (flag2 == 1) { # geneID and prot ID are completely different # make flags
  df_compara = dplyr::filter(df, source == "ensembl-compara") %>%
    dplyr::left_join(compara, by = c("to_geneID" = "OrthoDB_ID"), relationship = "many-to-many") %>%
    dplyr::mutate(to_geneID = Ortholog) %>%
    dplyr::select(-Ortholog)  
} else {
    df_compara = dplyr::filter(df, source == "ensembl-compara") %>%
    dplyr::left_join(compara, by = c("to_protID" = "OrthoDB_ID"), relationship = "many-to-many") %>%
    dplyr::mutate(to_geneID = Ortholog) %>%
    dplyr::select(-Ortholog) 
}

df_compara = df_compara[!is.na(df_compara$to_geneID), ]


if (nrow(plaza) != 0) {
  df_plaza = dplyr::filter(df, source == "PLAZA") %>%
    dplyr::left_join(plaza, by = c("to_geneID" = "OrthoDB_ID"), relationship = "many-to-many") %>%
    dplyr::mutate(to_geneID = Ortholog) %>%
    dplyr::select(-Ortholog)
  df_plaza = df_plaza[!is.na(df_plaza$to_geneID), ]
}

if (nrow(plaza) != 0) {
  df_other = dplyr::filter(df, !(source %in% c("ensembl-compara", "PLAZA")))  
  dt = dplyr::bind_rows(df_compara, df_plaza, df_other)
} else {
  df_other = dplyr::filter(df, !(source %in% c("ensembl-compara")))
  dt = dplyr::bind_rows(df_compara, df_other)
}

ind = c(grep("from_geneID|to_geneID|source", colnames(dt)))
df = dt[, ..ind]
df = df[!duplicated(df), ]


if (nrow(plaza) != 0) {
  ind = which(df$source %in% c('ensembl-compara', 'PLAZA'))
  df$to_geneID[ind] = sub(pattern_in, pattern_out, df$to_geneID[ind]) # change logic as needed
} else {
  ind = which(df$source %in% c('ensembl-compara'))
  df$to_geneID[ind] = sub(pattern_in, pattern_out, df$to_geneID[ind]) # change logic as needed
}





df %>%
  dplyr::group_by(source) %>%
  dplyr::slice_head(n = 2) %>%
  dplyr::bind_rows(df %>% dplyr::group_by(source) %>% dplyr::slice_tail(n = 2)) %>%
  dplyr::arrange(source) %>%
  dplyr::ungroup() -> first_last_three_per_source

print(first_last_three_per_source, n = nrow(first_last_three_per_source))

df = df[!duplicated(df), ]

```


```{r,  echo=TRUE, warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE}

rm(list = setdiff(ls(), c("df",
                          "ath.gmm", "gn", "sn", "pss_long", 
                          "plantName1", 
                          "plantNameOut", 
                          "plantDirOut",
                          "pattern_in", 
                          "pattern_out", 
                          "mercator", 
                          "mercatorPatternIn1", 
                          "mercatorPatternOut1", 
                          "mercatorPatternIn2", 
                          "mercatorPatternOut2",
                          "flag1", "flag2")))




gc()


library(magrittr)
# library(data.table)
library(ggplot2)
library(ComplexUpset)

```

## To wide format

```{r, chunk.label = paste0("wide_", plantName1), echo=TRUE, eval=TRUE}

dt = df
length(unique(dt$from_geneID))
length(unique(dt$to_geneID))

table(dt$source)


dt[, present := TRUE]

dt.wide = dcast(dt, from_geneID + to_geneID ~ source, value.var = "present", fill = FALSE)

dt.wide = dt.wide[order(dt.wide$from_geneID, dt.wide$to_geneID), ]


```


## Upset plot

```{r, chunk.label = paste0("upset_", plantName1), echo=TRUE, eval=TRUE}

if (flag1 == 1) {
  source_cols = c("MCScanX", "ensembl-compara", "PLAZA", 'OrthoDB', 'RBH', "FastOMA")
} else if (flag1 == 2) {
  source_cols = c("MCScanX", "ensembl-compara", 'OrthoDB', 'RBH', "FastOMA")
} else if (flag1 == 3) {
  source_cols = c("MCScanX", 'OrthoDB', 'RBH', "FastOMA")
} else {
  c("MCScanX", 'RBH', "FastOMA")
}


dt.wide[, count_evidence := rowSums(.SD), .SDcols = source_cols]

hist(dt.wide$count_evidence, main = paste0('# ath-', plantName1, ' evidence'))


dff = as.data.frame(dt.wide)

upset_plot = upset(
  dff,
  intersect = source_cols,
  name = "Source",
  width_ratio = 0.1,
  base_annotations = list(
    'Intersection size' = intersection_size(counts = FALSE) #,
    # 'Intersection ratio' = intersection_ratio()
  ),
  # Sort intersections first by degree (number of sets in intersection) descending,
  # then by intersection size (cardinality) descending within each degree
  sort_intersections_by = c("degree", "cardinality"),
  sort_intersections = "descending") + 
  ggtitle("Overlap of gene pairs supported by multiple methods")

# Print or save the plot
print(upset_plot)

ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "_upset_plot_2025-09-15.pdf"), 
       plot = upset_plot, width = 24, height = 6, device = "pdf") # change name




```


## Ath ORFs

* take care, ath cds (for MCScanX) fasta contains for e.g. besides AT1G30330.1, AT1G30330.2, AT1G30330.3

```
>AT1G30330.uORF1 pacid=37393466 polypeptide= locus=AT1G30330 ID=.Araport11.447 annot-version=Araport11
ATGATTTATTTCAGGGAAGAAGAAATAAATCTGTTTTTTTTAGGGTTTTTAGATTTGGTT
GGTGAATGGGTGGGAGGTGGAGGGAAACAGTTAAAAAAGTTATGCTTTTAG
>AT1G30330.uORF2 pacid=37393467 polypeptide= locus=AT1G30330 ID=.Araport11.447 annot-version=Araport11
ATGGGTGGGAGGTGGAGGGAAACAGTTAAAAAAGTTATGCTTTTAGTGTCTCTTCTTCAT
AATTACATTTGGGCATCTTGA
>AT1G30330.uORF3 pacid=37393468 polypeptide= locus=AT1G30330 ID=.Araport11.447 annot-version=Araport11
ATGAAGGAGTTGAAGATTCGAAGAAGCGGTTTTGAAGTCGGCGAGACCAAGATTGCGAGC
TTATTTGGCTGA
>AT1G30330.uORF5 pacid=37393469 polypeptide= locus=AT1G30330 ID=.Araport11.447 annot-version=Araport11
ATGCTTTTAGTGTCTCTTCTTCATAATTACATTTGGGCATCTTGA
>AT1G30330.uORF4 pacid=37393470 polypeptide= locus=AT1G30330 ID=.Araport11.447 annot-version=Araport11
ATGCCCCATATCTCTCTGTTTCTCATTTCCCGATCTTTGCATTAA
```

```{r, chunk.label = paste0("ORFs_", plantName1), echo=TRUE, eval=TRUE}

dt.wide[grep('ORF', dt.wide$from_geneID), ]
dt.wide = dt.wide[grep('ORF', dt.wide$from_geneID, invert = TRUE), ]


```

## Gene occurence

```{r, chunk.label = paste0("occurence_", plantName1), echo=TRUE, eval=TRUE}


# counting occurences
from_counts = dt.wide[, .N, by = from_geneID]
setnames(from_counts, "N", "from_count")
to_counts = dt.wide[, .N, by = to_geneID]
setnames(to_counts, "N", "to_count")
dt.wide = merge(dt.wide, to_counts, by = "to_geneID", all.x = TRUE)
dt.wide = merge(dt.wide, from_counts, by = "from_geneID", all.x = TRUE)

ind = c(grep('from_geneID|to_geneID|FastOMA|MCScanX|OrthoDB|PLAZA|RBH|ensembl-compara', colnames(dt.wide)), 
        grep('from_count', colnames(dt.wide)),
        grep('to_count', colnames(dt.wide)), 
        grep('count_evidence', colnames(dt.wide)))
##### take care here
dt.wide = dt.wide[, ..ind]




```


## In/out PSS


```{r, chunk.label = paste0("Ath-SKM-in-out_", plantName1), echo=TRUE, eval=TRUE}

df = merge(dt.wide, ath.gmm, by.x = 'from_geneID', by.y = 'IDENTIFIER', all.x = TRUE, all.y = FALSE)

df = merge(df, gn, by.x = 'from_geneID', by.y = 'V1', all.x = TRUE) # 
df = merge(df, sn, by.x = 'from_geneID', by.y = 'V1', all.x = TRUE) # 

df = merge(df, pss_long, by.x = 'from_geneID', by.y = 'id', all.x = TRUE)

nin = pss_long[which(!(pss_long$id %in% df$from_geneID)), ]
nin = nin[grep('^AT', nin$id), ]
nin = merge(nin, ath.gmm, by.x = 'id', by.y = 'IDENTIFIER', all.x = TRUE)
nin = merge(nin, gn, by.x = 'id', by.y = 'V1', all.x = TRUE)
nin = merge(nin, sn, by.x = 'id', by.y = 'V1', all.x = TRUE)

openxlsx::write.xlsx(nin, 
                     paste0('../reports/fruitTrees/', plantNameOut, '/', plantNameOut , '-ath_pss_no-orthologues_2025-09-15.xlsx'), 
                     asTable = TRUE) # change name





```


## fruitTrees plant gmm

```{r, chunk.label = paste0("plant-gmm_", plantName1), echo=TRUE, eval=TRUE}


fp = file.path('..', 'input', 'Mercator')
fn = mercator
gmm = data.table::fread(file.path(fp, fn), header = TRUE, fill = TRUE)
gmm = gmm[gmm$IDENTIFIER != "''", ]

combined = gmm[, .(
  BINCODE = paste(unique(BINCODE), collapse = " | "),
  NAME = paste(unique(NAME), collapse = " | "),
  DESCRIPTION = paste(unique(DESCRIPTION), collapse = " | ")
), by = IDENTIFIER]

charToRaw(combined$IDENTIFIER[1])
# combined$IDENTIFIER = sapply(combined$IDENTIFIER, function(x) paste(unlist(strsplit(x, "_"))[1:2], collapse = "_")) # change as needed
# combined$IDENTIFIER = sub("[\u2018\u2019\u201C\u201D']", "", combined$IDENTIFIER, perl = TRUE)  # change as needed
# charToRaw(combined$IDENTIFIER[1])
# combined$IDENTIFIER = sub("[\u2018\u2019\u201C\u201D']", "", combined$IDENTIFIER, perl = TRUE)  # change as needed
# charToRaw(combined$IDENTIFIER[1])
# When the ' character appears more than once in a string (such as at both start and end), sub() will remove only one occurrence per call.
combined$IDENTIFIER = gsub(mercatorPatternIn1, mercatorPatternOut1, combined$IDENTIFIER, perl = TRUE)  # change as needed
charToRaw(combined$IDENTIFIER[1])
combined$IDENTIFIER = paste0(toupper(substring(combined$IDENTIFIER, 1, 1)), substring(combined$IDENTIFIER, 2))  # change as needed
combined$IDENTIFIER = gsub(mercatorPatternIn2, mercatorPatternOut2, combined$IDENTIFIER, perl=TRUE) # change as needed;
combined$IDENTIFIER = sub(pattern_in, pattern_out, combined$IDENTIFIER, perl=TRUE)
table(combined$IDENTIFIER %in% dt$to_geneID)


combined$BINCODE = sub("\\'", '', combined$BINCODE )
combined$NAME = sub("\\'", '', combined$NAME)
combined$DESCRIPTION = sub("\\'", '', combined$DESCRIPTION)

colnames(combined)[2:4] = paste('fruitTrees', colnames(combined)[2:4], sep = '_')

colnames(df)
dt = merge(df, combined, by.x = 'to_geneID', by.y = 'IDENTIFIER', all.x = TRUE, all.y = FALSE)
table(is.na(dt$fruitTrees_BINCODE))
dt[is.na(dt$fruitTrees_BINCODE), ]$to_geneID # check ones with strange ID

dt_cols = colnames(df)
new_cols = setdiff(colnames(dt), c(dt_cols))
dt = as.data.frame(dt)
df = dt[, c(dt_cols, new_cols)]



```


```{r, echo=TRUE, eval=TRUE}

rm(list = setdiff(ls(), c("df", 
                          "ath.gmm", "gn", "sn", "pss_long",  
                          "plantName1", 
                          "plantNameOut", 
                          "plantDirOut", 
                          "pattern_in", 
                          "pattern_out", 
                          "mercator", 
                          "mercatorPatternIn1", 
                          "mercatorPatternOut1", 
                          "mercatorPatternIn2", 
                          "mercatorPatternOut2",
                          "flag1", "flag2")))


gc()


library(magrittr)
library(ggplot2)
library(ComplexUpset)


```




## Translation table

MapMan Mercator matches: first three levels only



```{r, chunk.label = paste0("translation_", plantName1), echo=TRUE, eval=TRUE}

df = df[!duplicated(df), ]


compare_bin <- function(athMercator, plantXMercator) {
  # split string by | then by ; and trim tokens,
  # then truncate each token to first three dot-separated levels
  split_tokens = function(code) {
    if(is.na(code) || code == "") return(character(0))
    parts = stringr::str_split(code, "\\|", simplify = TRUE)
    tokens = unlist(lapply(parts, function(p) stringr::str_split(p, ";", simplify = TRUE)))
    tokens = unique(stringr::str_trim(tokens))
    
    # For each token, extract first 3 dot levels
    trunc3levels = function(token) {
      levels = unlist(stringr::str_split(token, "\\."))
      if(length(levels) > 3) {
        levels = levels[1:3]
      }
      paste(levels, collapse = ".")
    }
    
    truncated_tokens = sapply(tokens, trunc3levels)
    unique(truncated_tokens)
  }
  
  bin_set = split_tokens(athMercator)
  v4_set = split_tokens(plantXMercator)
  
  # Tokens that are common between sets truncated to 3 levels
  common_tokens = intersect(bin_set, v4_set)
  
  # Check if plantXMercator is exact duplication of athMercator token(s) (all plantXMercator tokens equal truncated bin_set token(s))
  v4_parts = stringr::str_split(plantXMercator, "\\|", simplify = TRUE)
  if(length(bin_set) == 1 &&
     length(v4_parts) > 1 &&
     all(split_tokens(plantXMercator) == bin_set)) {
    return(paste0("100% match based on ", bin_set))
  }
  
  # Check if sets are identical
  if(setequal(bin_set, v4_set)) {
    return(paste0("100% match based on ", paste(bin_set, collapse = ", ")))
  }
  
  # Partial match if any tokens overlap, mention those tokens
  if(length(common_tokens) > 0) {
    return(paste0("partial match based on ", paste(common_tokens, collapse = ", ")))
  }
  
  return("no match")
}



df = df %>%
  dplyr::rowwise() %>%
  dplyr::mutate(MapMan4_Match = compare_bin(ath_BINCODE, fruitTrees_BINCODE)) %>% # change name 
  dplyr::ungroup()



```


## Filter


```{r, chunk.label = paste0("filter_", plantName1), echo=TRUE, eval=TRUE}


# now

cat('####  ####  before filter ####  ####  \n')
length(unique(df$from_geneID))
length(unique(df$to_geneID))

range(df$from_count)
range(df$to_count)

length(unique(df$from_geneID[df$from_count > 30]))
length(unique(df$to_geneID[df$to_count > 30]))
cat('####  ####  ####  ####  \n')


dt = as.data.table(df)
dt[, filter_criteria := "reject"]
covered_genes = character()


if (flag1 == 1) {
  methods = c("MCScanX", "ensembl-compara", "PLAZA", 'OrthoDB', 'RBH', "FastOMA")
} else if (flag1 == 2) {  # make flags
  methods = c("MCScanX", "ensembl-compara", 'OrthoDB', 'RBH', "FastOMA")
} else if (flag1 == 3) {
  methods = c("MCScanX", 'OrthoDB', 'RBH', "FastOMA")
} else {
  c("MCScanX", 'RBH', "FastOMA")
}


match_categories = c("no match", "100% match based", "partial match")

long_dt = data.table::rbindlist(lapply(methods, function(method) {
  dt[, .(
    Method = method,
    Match_Type = c("no match", "100% match based", "partial match"),
    Count = c(
      sum(get(method) == TRUE & MapMan4_Match == "no match"),
      sum(get(method) == TRUE & stringr::str_detect(MapMan4_Match, "100% match based")),
      sum(get(method) == TRUE & stringr::str_detect(MapMan4_Match, "partial match"))
    )
  )]
}), use.names = TRUE)

long_dt[, Match_Type := factor(Match_Type, levels = c("no match", "partial match", "100% match based"))]

ggplot2::ggplot(long_dt, ggplot2::aes(x = Method, y = Count, fill = Match_Type)) +
  ggplot2::geom_bar(stat = "identity") +
  ggplot2::labs(title = "MapMan match types count per method",
                x = "Method",
                y = "Count",
                fill = "Match Type") +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
ggplot2::ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "-before_filter1.pdf"), 
                device = "pdf", width = 6, height = 6, units = "in")


dtsub = dt[, .SD, .SDcols = grep("count_evidence|MapMan4_Match", names(dt), value = TRUE)] 
dtsub$MapMan4_Match = sub('based on.*', '', dtsub$MapMan4_Match)
table(dtsub$MapMan4_Match)
table(dtsub$count_evidence, dtsub$MapMan4_Match)
tab = as.data.table(as.data.frame(table(dtsub$count_evidence, dtsub$MapMan4_Match)))
setnames(tab, c("count_evidence", "MapMan4_Match", "Freq"))

tab$MapMan4_Match = as.character(tab$MapMan4_Match)
tab$MapMan4_Match = factor(tab$MapMan4_Match, levels = c('no match', 'partial match ', '100% match '))

ggplot(tab, aes(x = factor(count_evidence), y = Freq, fill = MapMan4_Match)) +
  geom_bar(stat = "identity") +
  labs(title = "Frequency of count_evidence by MapMan4_Match",
       x = "count_evidence",
       y = "Frequency",
       fill = "MapMan4_Match") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot2::ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "-before_filter2.pdf"), 
                device = "pdf", width = 6, height = 6, units = "in")



# Initialize an empty set or list covered_genes.
# 
# For each method in the list:
# ["MCScanX", "ensembl-compara", "PLAZA", "OrthoDB", "RBH", "FastOMA"]
# 
# For every row in the data table dt:
# 
# a. Check if filter_criteria is "reject" for the row.
# 
# b. Check if the value of the column corresponding to method in this row is TRUE.
# 
# c. Check if from_geneID in this row is not in covered_genes.
# 
# d. If method is one of ["OrthoDB", "RBH", "FastOMA"]:
      # Check if gene pair is covered by all three methods:
      # If yes:
      # is_candidate = TRUE
      # new_criteria = "OrthoDB_FastOMA_RBH"
      # Else if gene pair is covered by any two of those three methods:
      # If yes:
      # is_candidate = TRUE
      # new_criteria = join the two method names with underscore, e.g. "OrthoDB_FastOMA" or "RBH_FastOMA" or "OrthoDB_RBH"
      # Else if MapMan4_Match string contains "match based on" and current method name:
      # is_candidate = TRUE
      # new_criteria = {method}_MapMan4 (e.g., "RBH_MapMan4")
      # Else:
      # is_candidate = FALSE


special_methods = c("OrthoDB", "RBH", "FastOMA")

# Initialize a named vector to count method_MapMan4 assignments
mapman4_counts = setNames(rep(0, length(special_methods)), paste0(special_methods, "_MapMan4"))

for (method in methods) {
  base_cond = dt$filter_criteria == "reject" & dt[[method]] == TRUE & 
               !(dt$to_geneID %in% covered_genes) & !(dt$from_geneID %in% covered_genes)
  add_cond = rep(TRUE, nrow(dt))
  
  if (method %in% special_methods) {
    add_cond = rep(TRUE, nrow(dt))
  }
  
  candidates = which(base_cond & add_cond)
  
  if (length(candidates) > 0) {
    if (method %in% special_methods) {
      for (i in candidates) {
        row = dt[i]
        covered_by = special_methods[sapply(special_methods, function(m) row[[m]] == TRUE)]
        count_covered = length(covered_by)
        
        is_candidate = FALSE
        new_criteria = NULL
        
        if (count_covered == 3) {
          is_candidate = TRUE
          new_criteria = "OrthoDB_FastOMA_RBH"
        } else if (count_covered == 2) {
          is_candidate = TRUE
          new_criteria = paste(sort(covered_by), collapse = "_")
        } else if (count_covered == 1) {
          # Check MapMan4_Match string contains "match based on" and method name (case-insensitive)
          if (grepl("match based on", row$MapMan4_Match, ignore.case = TRUE)) {
            is_candidate = TRUE
            new_criteria = paste0(method, "_MapMan4")
            
            # Increment count for this mapman4 assignment
            mapman4_counts[[new_criteria]] = mapman4_counts[[new_criteria]] + 1
          }
        }
        
        if (is_candidate) {
          dt[i, filter_criteria := new_criteria]
          # covered_genes = unique(c(covered_genes, row$to_geneID, row$from_geneID))
          covered_genes = unique(c(covered_genes, row$to_geneID))
        }
      }
    } else {
      dt[candidates, filter_criteria := method]
      # covered_genes = unique(c(covered_genes, dt[candidates, unique(to_geneID)], dt[candidates, unique(from_geneID)]))
      covered_genes = unique(c(covered_genes, dt[candidates, unique(to_geneID)]))
    }
  }
}

# After the loop, print checkpoint counts for method_MapMan4 assignments
print("MapMan4 assignment counts per method:")
print(mapman4_counts)

cat('####  ####  ####  ####  \n')
table(dt$filter_criteria)
cat('####  ####  ####  ####  \n')

df = dt

data.table::fwrite(df, 
                   paste0('../reports/fruitTrees/', plantNameOut, '/y_', plantNameOut, '-ath_orthologues-all_2025-09-15.txt'), 
                   sep = '\t')
openxlsx::write.xlsx(df, 
                     paste0('../reports/fruitTrees/', plantNameOut, '/y_', plantNameOut, '-ath_orthologues-all_2025-09-15.xlsx'), 
                     asTable = TRUE)


```



## Filtered

```{r,  chunk.label = paste0("kept_", plantName1), echo=TRUE, eval=TRUE}

rejected = df[df$filter_criteria == 'reject', ]
kept = df[df$filter_criteria != 'reject', ]


# Update counts by reference in dt.wide (no merge needed)
setDT(df)
df[, from_count := .N, by = from_geneID]
df[, to_count := .N, by = to_geneID]

kept[, from_count := .N, by = from_geneID]
kept[, to_count := .N, by = to_geneID]





par(mfrow = c(2,2))
xlim = c(0,100)
h1 = hist(df$from_count, plot = FALSE, breaks = "Sturges")
h2 = hist(kept$from_count, plot = FALSE, breaks = "Sturges")
h3 = hist(df$to_count, plot = FALSE, breaks = "Sturges")
h4 = hist(kept$to_count, plot = FALSE, breaks = "Sturges")
max_count = max(c(h1$counts, h2$counts, h3$counts, h4$counts))
hist(df$from_count, main = "df$from_count", xlab = "from_count", xlim = xlim, ylim = c(0, max_count))
hist(kept$from_count, main = "kept$from_count", xlab = "from_count", xlim = xlim, ylim = c(0, max_count))
hist(df$to_count, main = "df$to_count", xlab = "to_count", xlim = xlim, ylim = c(0, max_count))
hist(kept$to_count, main = "kept$to_count", xlab = "to_count", xlim = xlim, ylim = c(0, max_count))
par(mfrow = c(1,1))
mtext("Before and afer filter", side = 3, line = -1.5, outer = TRUE, cex = 1.5)


long_kept = data.table::rbindlist(lapply(methods, function(method) {
  kept[, .(
    Method = method,
    Match_Type = c("no match", "100% match based", "partial match"),
    Count = c(
      sum(get(method) == TRUE & MapMan4_Match == "no match"),
      sum(get(method) == TRUE & stringr::str_detect(MapMan4_Match, "100% match based")),
      sum(get(method) == TRUE & stringr::str_detect(MapMan4_Match, "partial match"))
    )
  )]
}), use.names = TRUE)

long_kept[, Match_Type := factor(Match_Type, levels = c("no match", "partial match", "100% match based"))]

ggplot2::ggplot(long_kept, ggplot2::aes(x = Method, y = Count, fill = Match_Type)) +
  ggplot2::geom_bar(stat = "identity") +
  ggplot2::labs(title = "MapMan match types count per method (after filter)",
                x = "Method",
                y = "Count",
                fill = "Match Type") +
  ggplot2::theme_minimal() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
ggplot2::ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "-after_filter1.pdf"), 
                device = "pdf", width = 6, height = 6, units = "in")


keptsub = kept[, .SD, .SDcols = grep("count_evidence|MapMan4_Match", names(kept), value = TRUE)] 
keptsub$MapMan4_Match = sub('based on.*', '', keptsub$MapMan4_Match)
table(keptsub$MapMan4_Match)
table(keptsub$count_evidence, keptsub$MapMan4_Match)
tab = as.data.table(as.data.frame(table(keptsub$count_evidence, keptsub$MapMan4_Match)))
setnames(tab, c("count_evidence", "MapMan4_Match", "Freq"))

tab$MapMan4_Match = as.character(tab$MapMan4_Match)
tab$MapMan4_Match = factor(tab$MapMan4_Match, levels = c('no match', 'partial match ', '100% match '))

ggplot(tab, aes(x = factor(count_evidence), y = Freq, fill = MapMan4_Match)) +
  geom_bar(stat = "identity") +
  labs(title = "Frequency of count_evidence by MapMan4_Match (after filter)",
       x = "count_evidence",
       y = "Frequency",
       fill = "MapMan4_Match") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot2::ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "-after_filter2.pdf"), 
                device = "pdf", width = 6, height = 6, units = "in")


keptsub = kept[, .SD, .SDcols = grep("FastOMA|MCScanX|OrthoDB|PLAZA|RBH|ensembl-compara|count_evidence|MapMan4_Match|filter_criteria", 
                                     names(kept), value = TRUE)] 
keptsub$MapMan4_Match = sub(' based on.*', '', keptsub$MapMan4_Match)
tab = as.data.table(as.data.frame(table(keptsub$count_evidence, keptsub$filter_criteria, keptsub$MapMan4_Match)))
setnames(tab, c("count_evidence", "filter_criteria", "MapMan4_Match", "Freq"))
tab$MapMan4_Match = factor(tab$MapMan4_Match, levels = c('no match', 'partial match', '100% match'))
tab = tab[Freq > 0]
tab[, count_evidence := factor(count_evidence)]
tab[, filter_criteria := factor(filter_criteria, levels = c("MCScanX", "ensembl-compara", "PLAZA",
                                                    "OrthoDB_FastOMA_RBH",
                                                    "FastOMA_OrthoDB", "OrthoDB_FastOMA", "OrthoDB_RBH", "FastOMA_RBH", 
                                                    "OrthoDB_MapMan4", "RBH_MapMan4", "FastOMA_MapMan4"
                                                    ))]
tab[, MapMan4_Match := factor(MapMan4_Match, levels = c('no match', 'partial match', '100% match'))]


ggplot(tab, aes(x = filter_criteria, y = Freq, fill = MapMan4_Match)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ count_evidence, nrow = 2, drop = TRUE) +
  labs(
    title = "Frequency by MapMan4_Match (after filter)",
    x = "KG Criteria",
    y = "Frequency",
    fill = "MapMan4 Match"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # border around each facet
  )
ggplot2::ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "-after_filter3.pdf"), 
                device = "pdf", width = 6, height = 6, units = "in")


openxlsx::write.xlsx(rejected, 
                     paste0('../reports/fruitTrees/', plantNameOut, '/y_', plantNameOut, '-ath_orthologues-removed_2025-09-15.xlsx'), 
                     asTable = TRUE)


edges = unique(kept[, .(from_geneID, to_geneID)])
g = igraph::graph_from_data_frame(edges, directed = FALSE)
comp = igraph::components(g)
membership_dt = data.table(
  geneID = names(comp$membership),
  weak_component = comp$membership
)
# in case of directed graph
kept = merge(kept, membership_dt, by.x = "from_geneID", by.y = "geneID", all.x = TRUE)
# setnames(kept, "weak_component", "from_component")
# kept = merge(kept, membership_dt, by.x = "to_geneID", by.y = "geneID", all.x = TRUE)
# setnames(kept, "weak_component", "to_component")
# # but its undirected
# kept[, weak_component := from_component]
#  # cleanup
# kept[, c("from_component", "to_component") := NULL]


openxlsx::write.xlsx(kept, 
                     paste0('../output/y_', plantNameOut , '-ath_orthologues-kept_2025-09-15.xlsx'), 
                     asTable = TRUE)


if (flag1 == 1) {
  source_cols = c("MCScanX", "ensembl-compara", "PLAZA", 'OrthoDB', 'RBH', "FastOMA")
} else if (flag1 == 2) {  # make flags
  source_cols = c("MCScanX", "ensembl-compara", 'OrthoDB', 'RBH', "FastOMA")
} else if (flag1 == 3) {
  source_cols = c("MCScanX", 'OrthoDB', 'RBH', "FastOMA")
} else {
  c("MCScanX", 'RBH', "FastOMA")
}





# https://krassowski.github.io/complex-upset/articles/Examples_R.html
upset_plot = upset(
  kept,
  intersect = source_cols,
  name = "Source",
  width_ratio = 0.1,
  base_annotations = list(
    'Intersection size' = intersection_size(counts = FALSE) #,
    # 'Intersection ratio' = intersection_ratio()
  ),
  # Sort intersections first by degree (number of sets in intersection) descending,
  # then by intersection size (cardinality) descending within each degree
  sort_intersections_by = c("degree", "cardinality"),
  sort_intersections = "descending") + 
  ggtitle("Overlap of gene pairs supported by multiple methods (after filter)")

# Print or save the plot
print(upset_plot)

ggsave(paste0("../reports/fruitTrees/", plantNameOut, '/', plantNameOut, "_upset_plot_kept_2025-09-15.pdf"), 
       plot = upset_plot, width = 24, height = 6, device = "pdf")



cat('####  ####  after filter ####  ####  \n')
length(unique(kept$from_geneID))
length(unique(kept$to_geneID))

range(kept$from_count)
range(kept$to_count)

length(unique(kept$from_geneID[kept$from_count > 30]))
length(unique(kept$to_geneID[kept$to_count > 30]))
cat('####  ####  ####  ####  \n')


```



## PSS kept/rejected

```{r,  chunk.label = paste0("pss-kept-removed_", plantName1), echo=TRUE, eval=TRUE}


pss_long = pss_long[, grep("id$|all_pathways$|short_name$", colnames(pss_long))]
pss_long = pss_long[!duplicated(pss_long), ]
pss_long = merge(pss_long, 
                 df[, .SD, .SDcols = grep("from_geneID|to_geneID|ath_BINCODE|ath_NAME|ath_DESCRIPTION|athName|athSynonims|MapMan4_Match|filter_criteria", 
                                          names(dt), value = TRUE)],
                 by.x = 'id', by.y = 'from_geneID', all.x = TRUE, all.y = FALSE)
pss_long = pss_long[grep('^AT', pss_long$id), ]
pss_long = pss_long[!duplicated(pss_long), ]
table(pss_long$filter_criteria)

openxlsx::write.xlsx(pss_long, 
                     paste0('../reports/fruitTrees/', plantNameOut, '/', plantNameOut, '-ath_pss_orthologues-kept-rejected_2025-09-15.xlsx'), 
                     asTable = TRUE)

```



